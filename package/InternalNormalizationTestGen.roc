app [main] { pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.15.0/SlwdbJ-3GR7uBWQo6zlmYWNYOxnvo8r6YABXD-45UOw.tar.br" }

import pf.File
import pf.Arg
import "data/NormalizationTest.txt" as file : Str
import Helpers
#import pf.Stdout

template =
    """
    ## WARNING: This file is automatically generated. Do not edit it manually. ##
    app [main] { pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.15.0/SlwdbJ-3GR7uBWQo6zlmYWNYOxnvo8r6YABXD-45UOw.tar.br" }


    import CodePoint exposing [CodePoint]
    import pf.Stdout
    import pf.Utc
    import Normalization
    import Helpers

    convertedU32 : U32 -> CodePoint
    convertedU32 = \\cp ->
        when CodePoint.fromU32 cp is
        Ok x -> x
        Err _ -> crash "Invalid code point!"

    converted : List U32 -> List CodePoint
    converted = \\cps ->
        List.map cps convertedU32


    #doTest : (U64, {nfc: List U32, nfd: List U32, nfkd: List U32, nfkc: List U32}) -> Task {} *
    doTest = \\(index, {source: source, nfc: _nfc, nfd: _nfd, nfkd: nfkd, nfkc: _nfkc}) ->
        start = Utc.now! {}
        result = Normalization.toNFD (converted source)
        stop = Utc.now! {}
        time = Utc.deltaAsNanos start stop |> Num.toStr
        resultU32 = List.map result CodePoint.toU32
        if resultU32 == nfkd then
            Stdout.line "Test \$(Num.toStr index) complete in \$(time)"
        else
            intended = converted nfkd |> Normalization.showCodePoints |> Inspect.toStr
            actual = result |> Normalization.showCodePoints |> Inspect.toStr
            Stdout.line "Test failed: \$(Num.toStr index). Expected \$(intended). Got \$(actual)."

    tests = [$(tests)]

    main =


        Task.forEach tests doTest


    """

TestData : {source: List U32, nfc: List U32, nfd: List U32, nfkd: List U32, nfkc: List U32}

makeNfcTest : TestData, U64 -> Str
makeNfcTest = \data, index ->
    """
        ($(Num.toStr (index + 44)), $(Inspect.toStr data)),
    """

parseLine : Str -> Result TestData [Comment]
parseLine = \str ->
    when Helpers.startsWithHex str is
      Err _ -> Err Comment
      Ok s ->
        when Str.split s ";" is
            [sourceStr, nfcStr, nfdStr, nfkcStr, nfkdStr, ..] ->
                source = Str.split sourceStr " " |> List.map Helpers.hexStrToU32
                nfc = Str.split nfcStr " " |> List.map Helpers.hexStrToU32
                nfd = Str.split nfdStr " " |> List.map Helpers.hexStrToU32
                nfkc = Str.split nfkcStr " " |> List.map Helpers.hexStrToU32
                nfkd = Str.split nfkdStr " " |> List.map Helpers.hexStrToU32
                Ok {source, nfc, nfd, nfkd, nfkc}
            _ -> Err Comment

take : List a, U64 -> List a
take = \in, count ->
    takeHelper in count []

takeHelper : List a, U64, List a -> List a
takeHelper =\in, count, out ->
    when in is
    [] -> out
    _ if count <= 0 -> out
    [first, .. as rest] -> takeHelper rest (count - 1) (List.append out first)


tests = file |> Str.trim |> Str.split "\n" |> List.keepOks parseLine |> take 1_000 |> List.mapWithIndex makeNfcTest |> Str.joinWith "\n"

main =


    when Arg.list! {} |> List.get 1 is
        Err _ -> Task.err (InvalidArguments "USAGE: roc run InternalNormalizationTestGen.roc -- path/to/package/")
        Ok arg -> File.writeUtf8 "$(Helpers.removeTrailingSlash arg)/InternalNormalizationTest.roc" template
