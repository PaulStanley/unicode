app [main] { pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.15.0/SlwdbJ-3GR7uBWQo6zlmYWNYOxnvo8r6YABXD-45UOw.tar.br" }

import pf.File
import pf.Arg
import "data/NormalizationTest.txt" as file : Str
import Helpers
#import pf.Stdout

template =
    """
    ## WARNING: This file is automatically generated. Do not edit it manually. ##
    app [main] { pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.15.0/SlwdbJ-3GR7uBWQo6zlmYWNYOxnvo8r6YABXD-45UOw.tar.br" }


    import CodePoint exposing [CodePoint]
    import pf.Stdout
    import pf.Utc
    import Normalization
    import Helpers

    convertedU32 : U32 -> CodePoint
    convertedU32 = \\cp ->
        when CodePoint.fromU32 cp is
        Ok x -> x
        Err _ -> crash "Invalid code point!"

    converted : List U32 -> List CodePoint
    converted = \\cps ->
        List.map cps convertedU32

    equalCodePoints : List CodePoint, List CodePoint -> Bool
    equalCodePoints = \\cp1, cp2 ->
        when (cp1, cp2) is
        ([], []) -> Bool.true
        ([h1, .. as t1], [h2, .. as t2]) if (CodePoint.toU32 h1) == (CodePoint.toU32 h2) ->
            equalCodePoints t1 t2
        _ -> Bool.false

    #doTest : (U64, {nfc: List U32, nfd: List U32, nfkd: List U32, nfkc: List U32}) -> Task {} *
    doTest = \\(index, {source: sourceR, nfc: nfcR, nfd: nfdR, nfkd: nfkdR, nfkc: nfkcR}) ->
        nfc = converted nfcR
        nfd = converted nfdR
        nfkd = converted nfkdR
        nfkc = converted nfkcR
        source = converted sourceR

        start = Utc.now! {}
        nfc1 = Normalization.toNFC source
        nfc2 = Normalization.toNFC nfc
        nfc3 = Normalization.toNFC nfd
        nfc4 = Normalization.toNFC nfkd
        nfc5 = Normalization.toNFC nfkc

        nfd1 = Normalization.toNFD source
        nfd2 = Normalization.toNFD nfc
        nfd3 = Normalization.toNFD nfd
        nfd4 = Normalization.toNFD nfkd
        nfd5 = Normalization.toNFD nfkc
        stop = Utc.now! {}
        nfcResult =
            equalCodePoints nfc1 nfc &&
            equalCodePoints nfc2 nfc &&
            equalCodePoints nfc3 nfc &&
            equalCodePoints nfc4 nfkc &&
            equalCodePoints nfc5 nfkc

        nfdResult =
            equalCodePoints nfd1 nfd &&
            equalCodePoints nfd2 nfd &&
            equalCodePoints nfd3 nfd &&
            equalCodePoints nfd4 nfkd &&
            equalCodePoints nfd5 nfkd
        time = Utc.deltaAsNanos start stop |> Num.toStr
        if nfcResult && nfdResult then
            Stdout.line "Test \$(Num.toStr index) complete in \$(time)"
        else
            sourceStr = Normalization.showCodePoints source |> Inspect.toStr
            nfcStr = Normalization.showCodePoints nfc |> Inspect.toStr
            nfc1Str = Normalization.showCodePoints nfc1 |> Inspect.toStr
            nfc2Str = Normalization.showCodePoints nfc2 |> Inspect.toStr
            nfc3Str = Normalization.showCodePoints nfc3 |> Inspect.toStr
            nfc4Str = Normalization.showCodePoints nfc4 |> Inspect.toStr
            nfkcStr = Normalization.showCodePoints nfkc |> Inspect.toStr
            nfc5Str = Normalization.showCodePoints nfc5 |> Inspect.toStr

            nfdStr = Normalization.showCodePoints nfd |> Inspect.toStr
            nfd1Str = Normalization.showCodePoints nfd1 |> Inspect.toStr
            nfd2Str = Normalization.showCodePoints nfd2 |> Inspect.toStr
            nfd3Str = Normalization.showCodePoints nfd3 |> Inspect.toStr
            nfd4Str = Normalization.showCodePoints nfd4 |> Inspect.toStr
            nfkdStr = Normalization.showCodePoints nfkd |> Inspect.toStr
            nfd5Str = Normalization.showCodePoints nfd5 |> Inspect.toStr

            nfcResultStr =
                if nfcResult then
                    "NFC test passed."
                else
                    "NFC test failed.\\nSource     : \$(sourceStr)\\nNFC        : \$(nfcStr)\\nSource->NFC: \$(nfc1Str)\\nNFC->NFC   : \$(nfc2Str)\\nNFD->NFC   : \$(nfc3Str)\\nNFKC       : \$(nfkcStr)\\nNFKC->NFC  : \$(nfc4Str)\\nNFKD->NFC  : \$(nfc5Str)\\n"

            nfdResultStr =
                if nfdResult then
                    "NFD test passed"
                else
                    "NFD test failed.\\nSource     : \$(sourceStr)\\nNFC        : \$(nfdStr)\\nSource->NFD: \$(nfd1Str)\\nNFC->NFD   : \$(nfd2Str)\\nNFD->NFD   : \$(nfd3Str)\\nNFKD       : \$(nfkdStr)\\nNFKD->NFD  : \$(nfd4Str)\\nNFKC->NFD  : \$(nfd5Str)\\n"

            Stdout.line! "=== Test \$(Num.toStr index) failed.\\n\$(nfcResultStr)\\n\$(nfdResultStr)"


    tests = [$(tests)]

    main =


        Task.forEach tests doTest


    """

TestData : {source: List U32, nfc: List U32, nfd: List U32, nfkd: List U32, nfkc: List U32}

makeNfcTest : TestData, U64 -> Str
makeNfcTest = \data, index ->
    """
        ($(Num.toStr (index + 44)), $(Inspect.toStr data)),
    """

parseLine : Str -> Result TestData [Comment]
parseLine = \str ->
    when Helpers.startsWithHex str is
      Err _ -> Err Comment
      Ok s ->
        when Str.split s ";" is
            [sourceStr, nfcStr, nfdStr, nfkcStr, nfkdStr, ..] ->
                source = Str.split sourceStr " " |> List.map Helpers.hexStrToU32
                nfc = Str.split nfcStr " " |> List.map Helpers.hexStrToU32
                nfd = Str.split nfdStr " " |> List.map Helpers.hexStrToU32
                nfkc = Str.split nfkcStr " " |> List.map Helpers.hexStrToU32
                nfkd = Str.split nfkdStr " " |> List.map Helpers.hexStrToU32
                Ok {source, nfc, nfd, nfkd, nfkc}
            _ -> Err Comment

take : List a, U64 -> List a
take = \in, count ->
    takeHelper in count []

takeHelper : List a, U64, List a -> List a
takeHelper =\in, count, out ->
    when in is
    [] -> out
    _ if count <= 0 -> out
    [first, .. as rest] -> takeHelper rest (count - 1) (List.append out first)


tests = file |> Str.trim |> Str.split "\n" |> List.keepOks parseLine |> take 7000 |> List.mapWithIndex makeNfcTest |> Str.joinWith "\n"

main =


    when Arg.list! {} |> List.get 1 is
        Err _ -> Task.err (InvalidArguments "USAGE: roc run InternalNormalizationTestGen.roc -- path/to/package/")
        Ok arg -> File.writeUtf8 "$(Helpers.removeTrailingSlash arg)/InternalNormalizationTest.roc" template
