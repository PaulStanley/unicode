app [main] { pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.15.0/SlwdbJ-3GR7uBWQo6zlmYWNYOxnvo8r6YABXD-45UOw.tar.br" }

import pf.File
import pf.Arg
import "data/UnicodeData.txt" as file : Str
import Helpers

template =
    """
    ## WARNING: This file is automatically generated. Do not edit it manually ##
    module [
       canonicalDecompositionInternal,
       combiningClassInternal,
       canonicalCompositionInternal,
       compatibleDecompositionInternal]

    import InternalCP exposing [CP, toU32, fromU32Unchecked]

    $(combiningClass)

    $(canonicalDecompositionTable)

    $(canonicalCompositionTable)

    $(compatibleDecompositionTable)


    """

DecompMapping : [Canonical (List U32), Compatible (Str, List U32), None]
DecompRecord : { codepoint : U32, ccc : U8, decomposition : DecompMapping }

decompositionMapping : Str -> DecompMapping
decompositionMapping = \str ->
    split = Str.split str " "
    when split is
        [""] -> None
        [hd, .. as tl] if Str.startsWith hd "<" ->
            List.map tl Helpers.hexStrToU32
            |> \d -> Compatible (hd, d)

        x -> List.map x Helpers.hexStrToU32 |> Canonical

parseLine : Str -> Result DecompRecord [ParseFailure]
parseLine = \line ->
    when Str.split line ";" is
        [cp, _, _, cc, _, decomp, ..] ->
            decomposition = decompositionMapping decomp
            Ok {
                codepoint: Helpers.hexStrToU32 cp,
                ccc: Str.toU8 cc |> Result.withDefault 0u8,
                decomposition,
            }

        _ -> Err ParseFailure

makeCombiningClass : List Str, DecompRecord -> List Str
makeCombiningClass = \decomps, { ccc, codepoint, decomposition: _ } ->
    if ccc == 0 then
        decomps
    else
        output = "        $(Num.toStr codepoint) -> $(Num.toStr ccc)"
        List.append decomps output

makeCombiningTable = \data ->
    head =
        """
        # Return the combining class of a codepoint.
        combiningClassInternal : CP -> U8
        combiningClassInternal = \\cp ->
            when toU32 cp is
        """

    tail =
        """
                _ -> 0\n\n
        """

    List.walk data [] makeCombiningClass
    |> List.prepend head
    |> List.append tail
    |> Str.joinWith "\n"

makeCanonicalDecomposition : List Str, DecompRecord -> List Str
makeCanonicalDecomposition = \decomps, { codepoint, decomposition, ccc: _ } ->
    when decomposition is
        None -> decomps
        Compatible _ -> decomps
        Canonical d ->
            asStrings =
                d
                |> List.map \s -> "fromU32Unchecked $(Num.toStr s)"
                |> Str.joinWith ", "

            decomps
            |> List.append "        $(codepoint |> Num.toStr) -> Ok [$(asStrings)]"

makeCanonicalDecompTable = \data ->
    head =
        """
        # Return `Ok [<codepoints>]` if a codepoint can be canonically
        # decomposed, or `Err NoDecomp` if there is no canonical
        # decomposition for that codepoint.
        canonicalDecompositionInternal : CP -> Result (List CP) [NoDecomp]
        canonicalDecompositionInternal = \\cp ->
            when toU32 cp is
        """

    tail =
        "        _ -> Err NoDecomp"

    List.walk data [] makeCanonicalDecomposition
    |> List.append tail
    |> List.prepend head
    |> Str.joinWith "\n"

# This is an inverse mapping of (starter, combiner) to a canonical composition
# of the two. Note that this assumes that canonical combiners are always pairs
# and never more than that, which Unicode guarantees: "A canonical mapping may also
# consist of a pair of characters, but is never longer than two characters. When a
# canonical mapping consists of a pair of characters, the first character may itself
# be a character with a decomposition mapping, but the second character never has a
# decomposition mapping."
makeCanonicalComposition : DecompRecord -> Result Str [NotFound]
makeCanonicalComposition = \{ codepoint, decomposition, ccc: _ } ->
    when decomposition is
        None | Compatible _ -> Err NotFound
        Canonical [_singleton] -> Err NotFound
        Canonical [starter, combiner] -> Ok "        ($(starter |> Num.toStr), $(combiner |> Num.toStr)) -> Ok (fromU32Unchecked $(Num.toStr codepoint))"
        Canonical _ -> crash "unreachable"

makeCanonicalCompositionTable = \data ->
    head =
        """
        canonicalCompositionInternal : {starter: CP, combiner: CP} -> Result CP [NoComp]
        canonicalCompositionInternal = \\{starter, combiner} ->
            when (toU32 starter, toU32 combiner) is
        """
    tail =
        "        (_, _) -> Err NoComp"

    List.keepOks data makeCanonicalComposition
    |> List.append tail
    |> List.prepend head
    |> Str.joinWith "\n"

makeCompatibilityDecomposition : List Str, DecompRecord -> List Str
makeCompatibilityDecomposition = \decomps, { codepoint, decomposition, ccc: _ } ->
    when decomposition is
        None -> decomps
        Canonical _ -> decomps
        Compatible (_, d) ->
            asStrings =
                d
                |> List.map \x -> "fromU32Unchecked $(Num.toStr x)"
                |> Str.joinWith ", "
            decomps
            |> List.append "        $(codepoint |> Num.toStr) -> Ok [$(asStrings)]"

makeCompatibilityDecompositions = \data ->
    head =
        """
        # Return `Ok [<codepoints>]` if a codepoint can be compatibility
        # decomposed, or `Err NoDecomp` if there is no compatibility
        # decomposition for that codepoint.
        compatibleDecompositionInternal : CP -> Result (List CP) [NoDecomp]
        compatibleDecompositionInternal = \\cp ->
            when toU32 cp is
        """

    tail =
        "        _ -> Err NoDecomp"

    List.walk data [] makeCompatibilityDecomposition
    |> List.append tail
    |> List.prepend head
    |> Str.joinWith "\n"

parsedData =
    file
    |> Str.trim
    |> Str.split "\n"
    |> List.keepOks parseLine

combiningClass =
    parsedData
    |> makeCombiningTable

canonicalDecompositionTable =
    parsedData
    |> makeCanonicalDecompTable

canonicalCompositionTable =
    parsedData
    |> makeCanonicalCompositionTable

compatibleDecompositionTable =
    parsedData
    |> makeCompatibilityDecompositions

main =
    when Arg.list! {} |> List.get 1 is
        Err _ -> Task.err (InvalidArguments "USAGE: roc run InternalUCDataGen.roc -- path/to/package/")
        Ok arg -> File.writeUtf8 "$(Helpers.removeTrailingSlash arg)/InternalComposition.roc" template
